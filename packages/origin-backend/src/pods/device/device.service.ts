import {
    DeviceCreateData,
    DeviceStatusChangedEvent,
    DeviceUpdateData,
    IDevice,
    IDeviceProductInfo,
    IDeviceWithRelationsIds,
    IExternalDeviceId,
    ISmartMeterRead,
    ISmartMeterReadingsAdapter,
    SupportedEvents,
    DeviceSettingsUpdateData,
    ICertificationRequestBackend,
    ISmartMeterReadWithStatus,
    ISmartMeterReadStats,
    IEnergyGeneratedWithStatus,
    DeviceStatus,
    ILoggedInUser
} from '@energyweb/origin-backend-core';
import {
    Inject,
    Injectable,
    NotFoundException,
    UnprocessableEntityException
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { validate } from 'class-validator';
import { FindOneOptions, Repository, DeepPartial } from 'typeorm';
import { v4 as uuid } from 'uuid';

import moment from 'moment';
import { bigNumberify } from 'ethers/utils';
import { SM_READS_ADAPTER } from '../../const';
import { StorageErrors } from '../../enums/StorageErrors';
import { ConfigurationService } from '../configuration';
import { ExtendedBaseEntity } from '../ExtendedBaseEntity';
import { NotificationService } from '../notification';
import { OrganizationService } from '../organization/organization.service';
import { Device } from './device.entity';

@Injectable()
export class DeviceService {
    constructor(
        @InjectRepository(Device)
        private readonly repository: Repository<Device>,
        private readonly configurationService: ConfigurationService,
        private readonly organizationService: OrganizationService,
        private readonly notificationService: NotificationService,
        @Inject(SM_READS_ADAPTER) private smartMeterReadingsAdapter?: ISmartMeterReadingsAdapter
    ) {}

    async findByExternalId(
        externalId: IExternalDeviceId
    ): Promise<ExtendedBaseEntity & IDeviceWithRelationsIds> {
        const devices = ((await this.repository.find({
            loadEagerRelations: true
        })) as IDevice[]) as (ExtendedBaseEntity & IDeviceWithRelationsIds)[];

        const device = devices.find((d) =>
            d.externalDeviceIds.find((id) => id.id === externalId.id && id.type === externalId.type)
        );

        device.meterStats = await this.getMeterStats(device.id.toString());

        return device;
    }

    async findOne(
        id: string,
        options: FindOneOptions<Device> = {}
    ): Promise<ExtendedBaseEntity & IDeviceWithRelationsIds> {
        const device = ((await this.repository.findOne(id, {
            loadRelationIds: true,
            ...options
        })) as IDevice) as ExtendedBaseEntity & IDeviceWithRelationsIds;

        if (this.smartMeterReadingsAdapter) {
            device.smartMeterReads = [];
        }

        device.meterStats = await this.getMeterStats(device.id.toString());

        return device;
    }

    async create(data: DeviceCreateData, loggedUser: ILoggedInUser) {
        const configuration = await this.configurationService.get();
        const organization = await this.organizationService.findOne(loggedUser.organizationId);

        const newEntity = new Device();

        Object.assign(newEntity, {
            ...data,
            status: data.status ?? DeviceStatus.Submitted,
            smartMeterReads: data.smartMeterReads ?? [],
            deviceGroup: data.deviceGroup ?? '',
            organization,
            externalDeviceIds: data.externalDeviceIds
                ? data.externalDeviceIds.map(({ id, type }) => {
                      if (
                          typeof id === 'undefined' &&
                          configuration.externalDeviceIdTypes?.find((t) => t.type === type)
                              ?.autogenerated
                      ) {
                          return { id: uuid(), type };
                      }

                      return { id, type };
                  })
                : []
        });

        const validationErrors = await validate(newEntity);

        if (validationErrors.length > 0) {
            throw new UnprocessableEntityException({
                success: false,
                errors: validationErrors
            });
        }

        await this.repository.save(newEntity);

        const meterStats = await this.getMeterStats(newEntity.id.toString());

        return {
            ...newEntity,
            meterStats
        };
    }

    async remove(entity: Device | (ExtendedBaseEntity & IDeviceWithRelationsIds)) {
        this.repository.remove((entity as IDevice) as Device);
    }

    async getAllSmartMeterReadings(id: string): Promise<ISmartMeterRead[]> {
        const device = await this.repository.findOne(id);

        if (this.smartMeterReadingsAdapter) {
            return this.smartMeterReadingsAdapter.getAll(device);
        }

        return device.smartMeterReads;
    }

    async addSmartMeterReading(id: string, newSmartMeterRead: ISmartMeterRead): Promise<void> {
        const device = await this.findOne(id);

        if (this.smartMeterReadingsAdapter) {
            await this.smartMeterReadingsAdapter.save(device, newSmartMeterRead);
            return;
        }

        if (device.smartMeterReads.length > 0) {
            if (
                newSmartMeterRead.timestamp <=
                device.smartMeterReads[device.smartMeterReads.length - 1].timestamp
            ) {
                throw new UnprocessableEntityException({
                    message: `Smart meter reading timestamp should be higher than latest.`
                });
            }
        }

        device.smartMeterReads = [...device.smartMeterReads, newSmartMeterRead];

        await this.repository.save((device as unknown) as DeepPartial<Device>);
    }

    async getAll(
        options: FindOneOptions<Device> = {}
    ): Promise<Array<ExtendedBaseEntity & IDeviceWithRelationsIds>> {
        const devices = ((await this.repository.find({
            loadRelationIds: true,
            ...options
        })) as IDevice[]) as (ExtendedBaseEntity & IDeviceWithRelationsIds)[];

        for (const device of devices) {
            if (this.smartMeterReadingsAdapter) {
                device.smartMeterReads = [];
            }

            device.meterStats = await this.getMeterStats(device.id.toString());
        }

        return devices;
    }

    async findDeviceProductInfo(externalId: IExternalDeviceId): Promise<IDeviceProductInfo> {
        const devices = await this.repository.find();

        return devices.find((device) =>
            device.externalDeviceIds.find(
                (id) => id.id === externalId.id && id.type === externalId.type
            )
        );
    }

    async update(
        id: string,
        update: DeviceUpdateData
    ): Promise<ExtendedBaseEntity & IDeviceWithRelationsIds> {
        const device = await this.findOne(id);

        if (!device) {
            throw new NotFoundException(StorageErrors.NON_EXISTENT);
        }

        device.status = update.status;

        try {
            await this.repository.save((device as unknown) as DeepPartial<Device>);

            const deviceManagers = await this.organizationService.getDeviceManagers(
                device.organization
            );

            const event: DeviceStatusChangedEvent = {
                deviceId: id,
                status: device.status,
                deviceManagersEmails: deviceManagers.map((u) => u.email)
            };

            this.notificationService.handleEvent({
                type: SupportedEvents.DEVICE_STATUS_CHANGED,
                data: event
            });

            return device;
        } catch (error) {
            throw new UnprocessableEntityException({
                message: `Device ${id} could not be updated due to an error ${error.message}`
            });
        }
    }

    async updateSettings(id: string, update: DeviceSettingsUpdateData) {
        const device = await this.findOne(id);

        if (!device) {
            throw new NotFoundException(StorageErrors.NON_EXISTENT);
        }

        device.automaticPostForSale = update.automaticPostForSale;
        if (update.automaticPostForSale) {
            device.defaultAskPrice = update.defaultAskPrice;
        }

        try {
            await this.repository.save((device as unknown) as DeepPartial<Device>);

            return {
                message: `Device ${id} successfully updated`
            };
        } catch (error) {
            throw new UnprocessableEntityException({
                message: `Device ${id} could not be updated due to an error ${error.message}`
            });
        }
    }

    private async getMeterStats(deviceId: string): Promise<ISmartMeterReadStats> {
        const smReads = await this.getAllSmartMeterReadings(deviceId);
        const certificationRequests = await this.getCertificationRequests(deviceId);

        return this.calculateCertifiedEnergy(this.resolveCertified(smReads, certificationRequests));
    }

    private async getCertificationRequests(
        deviceId: string
    ): Promise<ICertificationRequestBackend[]> {
        const device = await this.repository.findOne(deviceId, {
            relations: ['certificationRequests']
        });

        return device.certificationRequests;
    }

    private resolveCertified(
        smReads: ISmartMeterRead[],
        certificationRequests: ICertificationRequestBackend[]
    ): ISmartMeterReadWithStatus[] {
        return smReads.map((smRead) => {
            let certified = false;

            for (const certReq of certificationRequests) {
                if (!certReq.approved) {
                    continue;
                }

                const smReadTime = moment.unix(smRead.timestamp);
                const certificationFromTime = moment.unix(certReq.fromTime);
                const certificationToTime = moment.unix(certReq.toTime);

                if (smReadTime.isBetween(certificationFromTime, certificationToTime)) {
                    certified = true;
                    break;
                }
            }

            return {
                ...smRead,
                certified
            };
        });
    }

    private calculateCertifiedEnergy(smReads: ISmartMeterReadWithStatus[]): ISmartMeterReadStats {
        const energiesGenerated: IEnergyGeneratedWithStatus[] = [];

        for (let i = 0; i < smReads.length; i++) {
            const isFirstReading = i === 0;

            const { meterReading, timestamp, certified } = smReads[i];

            energiesGenerated.push({
                energy: bigNumberify(meterReading).sub(
                    isFirstReading ? 0 : bigNumberify(smReads[i - 1].meterReading)
                ),
                timestamp,
                certified
            });
        }

        const sumEnergy = (energyGens: IEnergyGeneratedWithStatus[]) =>
            energyGens.reduce((sum, energyGen) => sum.add(energyGen.energy), bigNumberify(0));

        return {
            certified: sumEnergy(energiesGenerated.filter((energyGen) => energyGen.certified)),
            uncertified: sumEnergy(energiesGenerated.filter((energyGen) => !energyGen.certified))
        };
    }

    async getSupplyBy(facilityName: string, status: DeviceStatus) {
        const _facilityName = `%${facilityName}%`;
        const result = await this.repository
            .createQueryBuilder('device')
            .where(
                `device.facilityName ilike :_facilityName ${
                    status > 0 ? `and device.status = :status` : ``
                }`,
                { _facilityName, status }
            )
            .getMany();
        return result;
    }
}
